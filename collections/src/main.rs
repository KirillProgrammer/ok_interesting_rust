fn main() {
    // Векторы
	let _v = vec![1, 2, 3]; // аннотация типа не требуется, выводится автоматически
	
	let mut v: Vec<i32> = Vec::new(); // требуется аннотация типа, так как язык не знает, какие данные мы будем хранить в векторе
	
	v.push(5);
	v.push(6);
	v.push(7);
	v.push(8);
	{
		let v = vec![0, 1, 2, 3, 4];
		let u = &v[1];
		println!("{}", u);
		
		match v.get(1) {
			Some(u) => println!("Второй элемент равен {}", u),
			None => println!("Второй элемент отсутствует"),
		}
	}

	// let does_not_exist = &v[100];  Такое обращение к несуществующему элементу вызовет панику и программа завершится
	let _does_not_exist = v.get(100); // Такое обращение к несузествующему эллементу вернет None и не выйдет из программы

	let mut v = vec![1, 2, 4, 4, 5];
	let first = &v[0];

	v.push(6);
	let first = &v[0]; // Если заново не переопределить указатель на первый элемент массива, то будет ошибка, так как при увеличении вектора на один элемент он мог сдвинутся в другое место в памяти, а значит и старый указатель указывает не туда, куда надо

	println!("Первый элемент равен {}", first);

	// Перебор значений 

	for i in &v {
		print!("{}", i);
	}
	println!();
	// Перебор изменяемых ссылок

	for i in &mut v {
		*i *= 2; // Для того чтобы изменить значение, на которое ссылается изменяемая ссылка, приходится использовать оператор разыменования (*), чтобы получить значение в i перед тем, как использовать оператор *=
		print!("{}", i);
	}
	println!();

}
